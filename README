This is a minimal implementation of modal in Rust inspired by Charles Frye's excellent minimodal walkthrough: https://github.com/charlesfrye/minimodal

## Motivation

I think Modal is amazing, and Python is a perfect first use case. 
However, at some point, other languages will likely need to be supported, and I think Rust is the best candidate.

1. Rust is statically typed, which means you avoid a whole set of runtime errors that you would have to gradually eliminate in Python.
    generally the thing that annoys me most when using modal is 
    getting dumb runtime errors that could easily have been avoided with a compiler
2. Rust is becoming more popular in data engineering.

This repo is an exploration of what Modal might look like in Rust. 

## Downsides
1. your environment on the server and client side has to be basically the same. IE you would not be able to do 
    ```rust
    with image.imports():
        import package #not locally installed
    ```
2. compilation errors might be hard to deal with 


## Description
As Rust is far less dynamic than Python, the implementation differs somewhat.

Instead of using a decorator to wrap the function, we use a macro that transforms our function into a struct of the same name
which implements the "Function" trait. The Function trait is defined as follows:

```rust
pub trait Function<I, O>
where
    I: Serialize + for<'de> Deserialize<'de> + Send + Sync + Debug + 'static,
    O: Serialize + for<'de> Deserialize<'de> + Send + Sync + Debug + 'static,
{
    type LocalOutput: Future<Output = O> + Send;
    type RemoteOutput: Future<Output = O> + Send;

    fn local(input: I) -> Self::LocalOutput;
    fn remote(input: I) -> Self::RemoteOutput;
}
```

Both the inputs and outputs must implement Serialize and Deserialize. This ensures that the arguments can be sent and received via gRPC.
In Python, you can often end up getting pickle errors at runtime when the object you are sending or receiving cannot be deserialized or serialized. 
Here, the contract is more explicit.

We would then use the macro like so:

```rust
#[function]
async fn add(a: i32, b: i32) -> Result<i32, MiniModalError> {
    a + b
}

#[tokio::main]
async fn main() {
    let result = add::remote((1, 2)).await;
}
```

## Foundational crates
1. tonic for building code from proto api spec
2. serde for defining serialization and deserialization format
3. tokio for async
